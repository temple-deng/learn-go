# 第十章 包和工具

## 10.1 包简介

当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，
Go 语言编译器的编译速度也明显快于其他编译语言。Go 语言闪电般的编译速度主要得益于三个语言特性。
第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件
来判断包的依赖关系。第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，
每个包可以被独立编译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出
信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入
包的文件，而不需要遍历所有依赖的文件。    

## 10.3 包声明

关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对应一个可执行程序，
也就是 main 包，这时候 main 包本身的导入路径是无关紧要的。名字为 main 的包是给 `go build`
构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。    

第二个例外，包所在的目录中可能有一些文件名是以 test.go 为后缀的 Go 源文件，并且这些源文件声明
的包名也是以 _test 为后缀名的。这种目录可以包含两种包：一种普通包，一种测试的外部扩展包。所有
以 _test 为后缀包名的测试外部扩展包都由 go test 命令独立编译，普通包和测试的外部扩展包是相互
独立的。    

第三个，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如 "gopkg.in/yaml.v2"。这种
情况下包的名字不包含版本号后缀，而是 yaml.    

## 10.4 导入声明

如果我们想同时导入两个有着相同名字的包，例如 math/rand 和 crypto/rand，那么导入声明必须至少
为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。    

```go
import (
  "crypto/rand"
  mrand "math/rand"
)
```     

当然如果没有重名包我们也还是可以使用重命名的方式的。   

## 10.5 包的匿名导入

如果只是导入包而不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：
它会计算包级变量的初始化表达式和执行导入包的 init 初始化函数。我们可以使用空白标识符来重命名
导入的包。    

`import _ "import/png"`     

这个被称为包的匿名导入。

## 10.7 工具

GOROOT 环境变量指定了 Go 的安装目录，以及自带的标准库包的位置。GOROOT 的目录结构和 GOPATH 类似。    

`go get` 命令获取的代码是真实的本地存储仓库，而不仅仅是复制源文件，因此你依然可以使用版本管理
工具比较本地代码的变更或者切换到其他的版本。     

如果指定 -u 参数，`go get` 命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。
如果不包含该标志参数的话，而且包已经在本地存在，那么代码将不会自动更新。    

每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径指定。    

`go install` 命令和 `go build` 命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。     

因为编译对应不同的操作系统平台和 CPU 架构，`go install` 命令会将编译结果安装到 GOOS 和 GOARCH
对应的目录      

针对不同操作系统或CPU 的交叉构建也是很简单的。只需要设置好目标对应的 GOOS 和 GOARCH，然后运行
构建命令即可。     

### 10.7.4 包文档

如果包的注释内容比较长，一般会放到一个独立的源文件中，这个专门用于保存包文档的源文件通常叫 doc.go。   

`go doc` 命令打印包的声明和每个成员的文档注释。   

`$ go doc time`     

或者是某个包成员的注释文档：    

`$ go doc time.Since`     

或者是某个具体包的一个方法的注释文档：   

`$ go doc time.Duration.Seconds`    

第二个工具是 `godoc`，它提供了可以相互交叉引用的 HTML 页面，但是包含和 `go doc` 命令
相同以及更多的信息。     

`$ godoc -http :8000`    

### 10.7.5 内部包

在 Go 中，包的封装机制是一个重要的特性，没有导出的标识符只在同一个包内部可以访问，
而导出的标识符则是面向全宇宙都是可见的。    

有时候，一个中间的状态可能也是有用的，对于一小部分信任的包是可见的，但并不是对所有
调用者可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们不想
内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，
或者我们只是想实验一个新包的的还不稳定的接口，暂时只暴露给一部分受限制的用户使用。    

为了满足这些需求，Go 语言的构建工具对包含 internal 名字的路径段的包导入路径做了特殊
处理。这种包叫 internal 包，一个 internal 包只能包和 internal 目录有同一个父目录
的包所导入。例如，net/http/internal/chunked 内部包只能被 net/http/httputil 或
net/http 包导入。    

### 10.7.6 查询包

`go list` 命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它
导入路径：    

```
$ go list github.com/go-sql-driver/mysql
github.com/go-sql-driver/mysql
```    