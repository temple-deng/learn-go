# 第三章 基础数据类型

<!-- TOC -->

- [第三章 基础数据类型](#第三章-基础数据类型)
  - [3.1 整型](#31-整型)
    - [3.1.1 算术知识补充](#311-算术知识补充)
  - [3.2 浮点数](#32-浮点数)
  - [3.3 复数](#33-复数)
  - [3.4 布尔型](#34-布尔型)
  - [3.5 字符串](#35-字符串)
    - [3.5.1 字符串字面值](#351-字符串字面值)
    - [3.5.3 UTF-8](#353-utf-8)
    - [3.5.4 字符串和 Byte 切片](#354-字符串和-byte-切片)
    - [3.5.5 字符串和数字的转换](#355-字符串和数字的转换)
  - [3.6 常量](#36-常量)
    - [3.6.1 iota 常量生成器](#361-iota-常量生成器)
    - [3.6.2 无类型常量](#362-无类型常量)
  - [3.7 总结](#37-总结)

<!-- /TOC -->

Go 语言将数据类型分为四类：基础类型、复合（聚合）类型、引用类型和接口类型。本章介绍基础
类型，包括：数字、字符串和布尔型。复合数据类型——数组和结构体——是通过组合简单类型，来表达
更加复杂的数据结构。引用类型包括指针、切片、字典、函数、通道，虽然数据种类很多，但他们都是
对程序中的一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的
拷贝。     

## 3.1 整型

Go 语言的数值类型包括几种不同大小的整型数、浮点数和复数。每种数值类型都决定了对应的大小
和是否支持正负符号。     

Go 语言同时提供了有符号和无符号整型的整数运算。这里有 int8、int16、int32 和 int64 四种
不同大小的带符号整型数类型，与此对应的是 unit8, uint16, uint32 和 uint64 四种无符号类型。      

这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应
用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的
假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。      

Unicode 字符 `rune` 类型是和 `int32` 等价的类型，通常用于表示一个 Unicode 码点。这两
个名称可以互换使用。同样 `byte` 也是 `uint8` 类型的等价类型，`byte` 类型一般用于强调
数值是一个原始数据而不是一个小的整数。      

最后还有一种无符号整数类型 `uintptr`，没有指定具体的 bit 大小但是足以容纳指针。uintptr
类型只有在底层变成才需要，特别是 Go 语言和 C语言函数库或操作系统接口相交互的地方。    

其中有符号整数采用 2 的补码形式表示，也就是最高位用作符号位，一个 n 位的有符号数的取值
是 -2<sup>n-1</sup>到 2<sup>n-1</sup>-1。无符号的话就是 0 到 2<sup>n</sup>-1。    

下面是 Go 语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序
排列：    

```go
*    /    %    <<     >>    &      &^
+    -    |    ^
==   !=   <    <=     >     >=
&&
||
```     

二元运算符有五种优先级。      

对于上表中前两行的运算符，例如+运算符还有一个与赋值相结合的对应运算符+=，可以用于
简化赋值语句。      

`+, -, *, /` 可以适用于整数、浮点数和复数，但是取余运算符 % 仅用于整数间的运算。在Go语
言中，%取模运算符的符号和被取模数的符号总是一致的，因此 -5%3  和 -5%-3  结果都是-2。
除法运算符 /  的行为则依赖于操作数是否为全为整数，比如 5.0/4.0  的结果是1.25，
但是5/4的结果是1，因为整数除法会向着0方向截断余数。       

如果一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的bit位才能正确表
示的话，就说明计算结果是溢出了。超出的高位的bit位部分将被丢弃。如果原始的数值是有
符号类型，而且最左边的bit为是1的话，那么最终结果可能是负的。       

布尔型、数值类型和字符串等基本类型都是可以使用第三行的二元比较运算符进行比较的。此外，
整数、浮点数和字符串可以根据比较结果排序。    

话说布尔型怎么比较。     

Go语言还提供了以下的bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号
数：     

```
&     位运算 AND
|     位运算 OR
^     位运算 XOR
&^    位清空 AND NOT
<<    左移
>>    右移
```     

### 3.1.1 算术知识补充

首先介绍原码、反码和补码的概念哈：    

+ **原码**：就是机器数，是加了一位符号位的二进制数，正数符号位为0，负数符号位为1。
+ **反码**：用原码求反码的方法是，正数不变，负数保留符号位 1 不变，剩下位按位取反。
+ **补码**：正数依旧不变，负数保留符号位不变，先求反码再加上1.      

然后介绍模、补数、同余，我们从现实生活举例来看：    

+ 我们将一个时钟的分针往前拨20分钟，和往后拨40分钟，得到的结果是一样的。
+ 把你的属年(属猴)往后退5年，和往前进7年，一样都是属兔。
+ 把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，得到的结果都是62。     

上述几组数字，有这样的关系：20 + 40 = 60， 5 + 7 = 12， 25 + 75 = 100。     

式中的60, 12, 100，就是 **模**。20和40，5和7，25和75，就是一对对 **互补** 的数字。
而且，20,80,140 在模式 60 的情况下就是互为 **同余**的数字。    

通俗解释下模、补数、同余的概念：     

+ **模**：就是一个轮回，比如分针转一圈，十二生肖一轮等等。
+ **互补** ：一个数值针对某个模的互补值就是这个数值加上或者减去多少能够等于模，或者等于
模的同余值。
+ **同余** ：一个数值加上或者减去模的整数倍得到的所有数值即为该数值的同余值(也就是除上
模，余数是一样，所以叫同余)，0是模的同余，-模也是模的同余。    

理解了什么是模，什么是互补、什么是同余，那么如果给一个模，以及一个值a，如果计算a的补数
(与a互补的值)呢，其实很简单，只需要拿模-a即可，计算同余值可以直接加上或者减去模的整数倍
即可。     

基本的位运算规则如下：    


符号 | 描述 | 运算规则
---------|----------|---------
 & | 与 | 两个位都为1时，结果才为1
 \| | 或 | 两个为都为0时，结果才为0
 ^ | 异或 | 两个位相同为0，相异为1
 ~ | 取反 | 
 `<<` | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0
 `>>` | 右移 | 各二进制位全部右移若干位，对无符号数，高位补0，有符号数编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）

位操作运算符 `^`  作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取
反；也就是说，它返回一个每个bit位都取反的数。位操作运算符 `&^`  用于按位置零（AND
NOT）：表达式 z = x &^ y  结果z的bit位为0，如果对应y中bit位为1的话，否则对应的bit位等
于x相应的bit位的值。      

```go
var x uint8 = 1<<1 | 1<<5
var y uint8 = 1<<1 | 1<<2

fmt.Printf("%08b\n", x)       // 00100010, the set {1, 5}
fmt.Printf("%08b\n", y)       // 00000110, the set {1, 2}

fmt.Printf("%08b\n", x&y)     // 00000010, the intersection {1}
fmt.Printf("%08b\n", x|y)     // 00100110, the union {1,2,5}
fmt.Printf("%08b\n", x^y)     // 00100100, the symmetric difference {2, 5}
fmt.Printf("%08b\n",x&^y)     // 00100000, the difference {5}
```

注意根据移位的操作来看，应该是通过补码进行操作的。无符号数的右移运算是用0填充左边空缺的bit位，
但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。      


任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头
的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。     

```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o)  // 438 666 0666
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// output
// 3735928559  deadbeef   0xdeadbeef   0XDEADBEEF
```    

请注意fmt的两个使用技巧。通常 `Printf` 格式化字符串包含多个 `%` 参数时将会包含对应
相同数量的额外操作数，但是%之后的 [1]  副词告诉Printf函数再次使用第一个操作数。第二，%后
的 #  副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。    

字符面值 rune 是用一对单引号包裹的对应字符，最简单的例子是 ASCII 中类似 'a' 写法的。但是
我们也可以通过转义的数值来表示任意的 Unicode 码点对应的字符。     

字符使用 `%c` 参数打印，或者是用 `%q` 参数打印带单引号的字符：    

```go
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)       // 97 a 'a'
fmt.Printf("%d %[1]c %[1]q\n", unicode)     // 22269  国 '国'
fmt.Printf("%d %[1]q\n", newline)           // 10 \n
```     


## 3.2 浮点数

Go 语言提供了两种精度的浮点数，`float32` 和 `float64`。它们的算术规范由 IEEE754 浮点
数国际标准定义。      

浮点数的范围极限值可以在 math 包找到。常量 `math.MaxFloat32` 表示 `float32` 能表示的
最大数值，大约是 `3.4e38`；对应的`math.MaxFloat64` 常量大约是 1.8e308。它们分别能表示
的最小值近似为 1.4e-45和 4.9e-324.      

一个 float32 类型的浮点数可以提供大约 6个十进制数的精度，而 float64 则可以提供约15个
十进制数的进度；通常应该优先使用 `float64` 类型，因为 `float32` 类型的累计计算误差
很容易扩散，并且 `float32` 能精确表示的正整数并不是很大。      

小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法
书写，通过e或E来指定指数部分：    

用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是
对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都
可以指定打印的宽度和控制打印精度。    

```go
 for x := 0; x < 8; x++ {
  fmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))
 }
```    

上面代码打印e的幂，打印精度是小数点后三个小数精度和8个字符宽度。    

math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的
创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除以零的结果；还有NaN
非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1).       

```go
var a float64
fmt.Println(a, -a, 1/a, -1/a, a/a)   // 0 -0 +Inf -Inf NaN
```      

函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以
用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因
为NaN和任何数都是不相等的（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一
的，每个都有非常多种的bit模式表示）：    

```go
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
```      

## 3.3 复数

Go 语言提供了两种精度的复数类型：complex64 和 complex128，分别对应 float32 和 float64
两种浮点数精度。内置的 `complex` 函数用于构建复数，内建的 `real` 和 `imag` 函数分别
返回复数的实部和虚部：     

```go
var x complex128 = complex(1,2)  // 1+2i
var y complex128 = complex(3,4)  // 3+4i
fmt.Println(x*y)   // (-5+10i)
fmt.Println(real(x*y))    //-5
fmt.Println(imag(x*y))    // 10
```     

如果一个浮点数面值或一个十进制整数面值后面跟着一个 i，例如 3.141592i 或 2i，它将构成一个
复数的虚部，复数的实部为0.      

在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），
我们可以用自然的方式书写复数：    

```go
x := 1 + 2i
y := 3 + 4i
```      

复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的。     


## 3.4 布尔型

一个布尔类型的值只有两种：true 和 false。if 和 for 语句的条件部分都是布尔类型的值，
并且 == 和 &lt; 等比较操作也是也会产生布尔型的值。一元操作符 `!` 对应逻辑非操作。     

布尔值可以和 && 和 || 操作符结合，并且可能会有短路行为。      

布尔值并不会隐式转换为数字值0或1，反之亦然。     

## 3.5 字符串

一个字符串是一个不可改变的字节序列。文本字符串通常被解释为采用UTF8编码的Unicode码点
（rune）序列。         

内置的 len 函数可以返回一个字符串中的字节数目（不是 rune 字符数目），索引操作 s[i]返回
第 i 个字节的字节值。第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8
编码会要两个或多个字节。     

如果索引超出字符串范围或者j小于i的话将导致panic异常。     

因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：    

`s[0] = 'L'   // compile error: cannot assign to s[0]`      


### 3.5.1 字符串字面值

字符串字面值必须用双引号包裹。     

在一个双引号包含的字符串字面值中，可以用以反斜杠 \  开头的转义序列插入任意的数据。下
面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：    

```
\a    响铃
\b    退格
\f    换页
\n    换行
\r    回车
\t    制表符
\v    垂直制表符
\'    单引号，只用在 '\'' 形式的 rune 字面值中
\"
\\    反斜杠
```     

可以通过十六进制或八进制转义在字符串字面值中包含任意的字节。一个十六进制的转义形式是\xhh，
其中两个 hh 表示十六进制数字（大写或小写都可以）。一个八进制转义形式是 \ooo，包含三个八进制
数字，但是不能超过 \377，对应一个字节的范围，十进制为255。每一个单一的字节表达一个特定
的值。       


一个原生的字符串字面值是写做 \`...\` 的形式，使用反引号而不是双引号。在原生字符串字面值
中，没有转义处理，全部的内容都是字面的意思，包括退格和换行。唯一的特殊处理时会删除回车以
保证在所有平台上的值都是一样的。      

```go
const GoUsage = `Go is a tool for managing Go source code.

Usage:
  go command [arguments]
...`
```    

### 3.5.3 UTF-8

每个符号编码后第一个字节的高端bit位用于表示总共有多少编码个字节。如果第一个字
节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统
的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节。     

Go 语言字符串字面值中的 Unicode 转义字符让我们可以通过 Unicode 码点输入特殊的字符。
有两种形式：`\uhhhh` 对应 16位的码点值，`\Uhhhhhhhh` 对应 32位的码点值。     

Unicode 转义也可以使用在 rune 字符中，下面三个字符是等价的：    

`'世'  '\u4e16'   '\U00004E16'`     

对于小于256码点值可以写在一个十六进制转义字节中，例如'\x41'对应字符'A'，但是对于更
大的码点则必须使用\u或\U转义形式。因此，'\xe4\xb8\x96'并不是一个合法的rune字符，虽然
这三个字节对应一个有效的UTF8编码的码点。这里指的是单个字符，在字符串中就可以使用
`\xe4\xb8\x96` 的形式。      

unicode 包提供了诸多处理 rune 字符相关的函数，unicode/utf8 包则提供了用于 rune 字符
序列的 UTF8 编码和解码功能。     

```go
import "unicode/utf8"

s := "Hello, 世界"
fmt.Println(len(s))                       // 13
fmt.Println(utf8.RuneCountInString(s))    // 9
```      

range循环在处理字符串的时候，会自动隐式解码UTF8字符串：    

```go
n := 0
for range s {
  n++
}
```     

UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为
rune大小一致，支持数组索引和方便切割。     

对一个字符串使用 `[]rune` 的类型转换，可以将字符串解码为 Unicode 码点序列：     

```go
s := "プログラム"
fmt.Printf("% x\n", s)    //e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0
r := []rune(s)
fmt.Printf("%x\n", r)    //[30d7 30ed 30b0 30e9 30e0]
```    

第一个 Printf 中 `% x` 参数用于在每个十六进制数字前插入一个空格。      

如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码：   

`fmt.Println(string(r))   // プログラム`   

将一个整数转型为字符串意思是生成包含对应Unicode码点字符的UTF8字符串：   

```go
fmt.Println(string(65)) // "A", not "65"
fmt.Println(string(0x4eac)) // "京"
```     

### 3.5.4 字符串和 Byte 切片

标准库中有四个包对字符串处理尤为重要：bytes, strings, strconv, unicode。strings 包
提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。    

strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相
关的转换。     

unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每
个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的
转换函数将用于rune字符的大小写转换。strings包也有类似的函数，它们是ToUpper和ToLower，
将原始字符串的每个字符都做相应的转换，然后返回新的字符串。     

一个字符串是包含的只读字节数组，一旦创建，是不可变的。相比之下，一个字节slice的元
素则可以自由地修改。   

字符串和字节 slice 之间可以相互转换：    

```go
s := "abc"
b := []byte(s)
s2 := string(b)
```     

从概念上讲，一个 []byte(s) 转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后
引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说
需要确保变量 b 在修改的情况下，原始的 s 字符串也不会改变。将一个字节 slice 转换到字符串
的 string(b) 操作则是构造一个字符串拷贝，以确保 s2 字符串是只读的。     

为了吧避免转换中不必要的内存分配，bytes 包和 strings 包提供了许多实用函数，下面是 strings
包中的六个函数：    

```go
func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string
```     

bytes 包中也对应的六个函数：   

```go
func Contains(b, subslice []byte) bool
func Count(s, sep []byte) int
func Fields(s []byte) [][]byte
func HasPrefix(s, prefix []byte) bool
func Join(s [][]byte, sep []byte) []byte
```    

bytes 包还提供了 Buffer 类型用于字节 slice 的缓存。一个 Buffer 开始是空的，但是随着
string、byte 或 byte[] 等类型数据的写入可以动态增长。      

### 3.5.5 字符串和数字的转换

字符串和数值之间的转换比较常见。由strconv包提供这类转换功能。     

将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用
strconv.Itoa(“整数到ASCII”)：    

```go
x := 123
y := fmt.Springf("%d", x)
fmt.Println(y, strconv.Itoa(x))
```     

FormatInt和FormatUint函数可以用不同的进制来格式化数字：     

`fmt.Println(strconv.FormatInt(int64(x), 2))   //1111011`     

如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无
符号整数的ParseUint函数.      

## 3.6 常量

常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型。  

和变量声明一样，可以批量声明多个常量；这比较适合声明一组相关的常量：    

```go
const (
  e = 2.71828
  pi = 3.1415926
)
```     

注意变量可以这样声明，而多个常量也支持下面这样声明：    

```go
const a, b = 3, 5
```     

个人感觉上面的写法可读性比较好，一眼就能看出来哪个变量赋了哪个值，而第二种
写法呢比较简洁，但是可读性差一点。    

常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作
或以下函数调用都是返回常量结果：`len, cap, real, imag, complex, unsafe.Sizeof`     

如果是批量声明的常量，除了第一个外的其它的常量右边的初始化表达式都可以省略，
如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也一样的：    

```go
const (
  a = 1
  b
  c = 2
  d
)
fmt.Println(a, b, c, d)
```       

如果只是简单地复制右边的常量表达式,其实并没有太实用的价值。但是它可以带来其它的
特性,那就是iota常量生成器语法。     

### 3.6.1 iota 常量生成器

常量声明可以使用 iota　常量生成器初始化，它用于生成一组以相似规则初始化的常量，
但是不用每行都写一遍初始化表达式。在一个 const　声明语句中，在第一个声明的
常量所在的行，iota 将会被置0，然后在每一个有常量声明的行加一。      

```go
type Weekday int

const (
  Sunday Weekday = iota
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
)
```     

我们也可以在复杂的常量表达式中使用 iota，下面是来自 net 包的例子，用于给一个
无符号整数的最低 5 bit 的每个bit指定一个名字：    

```go
type Flags uint

const (
  FlagUp Flags = 1 << iota
  FlagBroadcast
  FlagLoopback
  FlagPointToPoint
  FlagMulticast
)
```      

随着iota的递增,每个常量对应表达式1 << iota,是连续的2的幂,分别对应一个bit位置。使
用这些常量可以用于测试、设置或清除对应的bit位的值。     

### 3.6.2 无类型常量

Go 语言的常量有个不同寻常之处。有许多常量并没有一个明确的基础类型。编译器为这些
没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算。你可以认为至少有256
bit 的运算精度。这里有未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、
无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。        

也就是说针对常量，多出了这6种类型.    

math.Pi无类型的浮点数常量,可以直接用于任意需要浮点数或复数的地方:     

```go
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```      

只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，无类型的常量将会被隐
式转换为对应的类型,如果转换合法的话。     

```go
var f float64 = 3 + 0i // untyped complex -> float64
f = 2                  // untyped integer -> float64
f = 1e123              // untyped floating-point -> float64
f = 'a'                // untyped rune -> float64
```      

这个例子的意思是把字面值也当成常量了把。     

无论是隐式或显式转换,将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮
点数和复数,可能会有舍入处理：    

```go
const (
  deadbeef = 0xdeadbeef // untyped int with value 3735928559
  a = uint32(deadbeef)  // uint32 with value 3735928559
  b = float32(deadbeef) // float32 with value 3735928576 (rounded up)
  c = float64(deadbeef) // float64 with value 3735928559 (exact)
  d = int32(deadbeef)   // compile error: constant overflows int32
  e = float64(1e309)    // compile error: constant overflows float64
  f = uint(-1)          // compile error: constant underflows uint
)
```     

对于一个没有显式类型的变量声明语法(包括短变量声明语法),无类型的常量会被隐式转
为默认的变量类型,就像下面的例子:     

```go
i := 0      // untyped integer;        implicit int(0)
r := '\000' // untyped rune;           implicit rune('\000')
f := 0.0    // untyped floating-point; implicit float64(0.0)
c := 0i     // untyped complex;        implicit complex128(0i)
```     

注意默认类型是规则的:无类型的整数常量默认转换为int,对应不确定的内存大小,但是浮
点数和复数常量则默认转换为float64和complex128。      

注意常量变量和字面值常量还是有区别的，字面值都是一次性使用的，所以如果变量没声明类型，
就按上面的规则转换，如果有类型那就直接往对应的类型转，而常量变量是可以退后计算的，
所以可能对应常量最后的类型是一个综合考虑的结果。      


## 3.7 总结

Go 的类型系统将实体划分了四类：基础类型、聚合类型 aggregate types、引用类型和接口类型。
基础类型分为数值型、布尔型和字符串型。聚合类型分为数组和结构体。引用类型分为指针、slices、
map、函数和 channels。       

二元运算符：    

```
* / % << >> & &^
+ - | ^
== != < <= > >=
&&
||
```     

Printf 函数的小技巧：   

`fmt.Printf("%d %[1]x %#[1]x %#[1]X", x)`     

[1] 代表只用第一个操作数，不过这里注意了，索引的起始值竟然是1而不是0，%o, %x, %X 前的
\# 告诉 Printf 添加 0, 0x, 0X 前缀，注意在前面我们没有提到过 %X 函数，这里看意思是把
十六进制的字母都大写。    

`fmt.Printf("x = %d e^x = %8.3f", x, math.Exp(float64(x)))`    

8个字符宽度，小数点后3位，注意小数点也算一位。    

注意在 Go 中好像 0 做除数不违法，只是返回 -Inf 或 +Inf，不过 0/0 会返回 NaN。     

`len` 函数返回的是字符串字节的数量，索引访问s[i]也是访问的第 i 个字节的数据。比较运算符
也是一个字节一个字节的比较。说实话，这种设计并不好。     

字符串是不可修改的，因此尝试修改的操作会报错：    

`s[0] = 'L'   // compile error: cannot assgin to s[0]`     

可以在字符串字面量用十六进制\xhh，八进制\ooo，也可以用 Unicode 码点 \uhhhh、\Uhhhhhhhh，
还有转义字符串。十六进制和八进制只表示一个字节，八进制还必须小于377。     

下面的写法是相同的：    

```
"世界"
"\xe4\xb8\x96\xe7\x95\x8c"
"\u4e16\u754c"
"\U00004e16\U0000754c"
```    

rune 类型字面量中也可以使用 Unicode 码点，但只有小于 255 的字符可以使用十六进制的表示
方法。     

raw strings 的写法 \`...\`。     

