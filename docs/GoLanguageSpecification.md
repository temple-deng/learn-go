# The Go Programming Language Specification

## Constants 常量

Go 中有布尔常量、rune 常量、整型常量、浮点型常量、复数常量、字符串常量。rune、整型、
浮点型、复数常量统称为数值型常量。    

一个常量值可以用以下的内容来表示：   

+ 一个 rune、整型、浮点型、复数、字符串字面量（话说布尔哪去了）
+ 一个常量的标识符（这个其实包含了 true 和 false 吧）
+ 一个常量表达式（下面再说）
+ 结果是常量的类型转换
+ 一些内置函数的结果值，例如对数值型常量调用 complex 函数    

预定义标识符 `iota` 是一个整型常量。     

-0，无穷大和 NaN 不是常量。    

一个无类型的常量都有一个默认的类型，这个默认的类型是在需要一个有类型值时隐式转换的结果。
对于不同的类型，默认类型分别为 `bool, rune, int, float64, complex128, string`。    

## Properties of types and values

预定义类型：布尔、字符串、数值型。    

### Type identity

注意这里的类型相同不相同和可不可比较是不一样的，类型相不相同主要是在对一个变量重新赋值的
时候用到，你肯定只能给变量赋给它与其类型相同的值对吧。     

一个预定义的类型是永远和另一个预定义类型不同的。然而，如果两种类型的底层类型是相同的，
并且结构也是相同的，详细来说：    

+ 如果两个数组有相同的元素类型和数组长度，那么两个数组类型是相同的。
+ 两个 slice 类型相同如果它们有相同的元素类型
+ 如果两个结构体的字段相同那么这两个结构体就是类型相同的，这里的字段相同指的是，字段名都
相同，且字段的类型相同，且 tag 也相同。不同包的非导出字段名是永远不相同的。
+ 两个指针类型相同如果它们有相同的基础类型。
+ 如果两个函数的参数与返回值数量相同，且对应的参数和返回值的类型相同，且都有可变参数或都
没有。那么就可以认为两个函数类型是相同的。
+ 两个接口类型相同，如果它们的方法集是相同的，即方法名都一样，且方法的函数类型都一样。
不同包的非导出方法名永远不相同。
+ 两个 map 类型相同，如果其键名和键值的类型相同
+ 两个 channel 类型相同，如果它们有相同的元素类型和相同的方向。     

### 可赋值性

一个值 `x` 是可赋值给一个类型为 `T` 的变量，如果满足下面之一的条件：   

+ `x` 的类型就是 `T`
+ `x` 的类型是 `V`，`V` 和 `T` 有相同底层类型，并且`V` 和 `T` 至少有一个不是预定义类型
+ `T` 是一个接口类型，`x` 实现了接口 `T`
+ `x` 是一个双向 channel 值，`T` 是一个 channel 类型，`x` 的类型 `V` 和 `T` 是相同的
元素类型，并且`V` 和 `T` 至少有一个不是预定义类型
+ `x` 是 `nil`，`T` 是一种引用类型或者接口类型
+ `x` 是一个可用类型 `T` 的值代表的无类型常量，这个就比较抽象了，个人觉得这里可代表意指
可以成功转换     

### Representability 可代表性

一个常量 `x` 是可以用类型 `T` 的值代表的，如果满足以下之一的条件：    

+ `x` 就是 `T` 类型
+ `T` 是浮点型，`x` 在不溢出的情况下可以舍入到 `T` 的精度。
+ `T` 是复数类型， `x` 的实部和虚部可以被 `T` 类型代表     

## Blocks

除了代码中显示的代码块，还有以下隐式的代码块：   

1. 所有的 Go 代码组成的通用块 universe block
2. 每个包自己的一个包块 package block
3. 每个文件自己的文件块 file block
4. 每个 `if`, `for`, `switch` 语句也是一个块
5. `switch` 和 `select` 中的每个分支     

## Declarations and scope 声明及作用域

每条声明语句将一个非空的标识符和一个常量、类型、变量、函数、label或者 package 绑定到一起。程序中的每个标识符必须被声明。同一块中的一个标识符只能被声明一次。同时，一个标识符只能同时在文件及包作用域中声明一次。     

空白标识符 `_` 可以像其他标识符一样用在声明中，但是它不会引入一个绑定操作，因此其实这个
标识符是未声明的。在包块一级的作用域中，标识符 `init` 可以用作 `init` 函数声明，而且与
空白标识符一样也不会引入一个绑定操作。    

说白了就是空白标识符和 `init` 也怎么声明也不会产生冲突。     

```
Declararion = ConstDecl | VarDecl | TypeDecl
TopLevelDecl = Declaration | FunctionDecl | MethodDecl
```     

上面的意思可能是，常量、类型与变量声明可以在任意级别的块中声明，但是函数和方法声明只能在
顶层的块中声明，这里顶层的块中可能就是指不在函数内。      

Go 使用了块的词法作用域：    

1. 预定义的标识符的作用域是整个通用块 universe block
2. 定义在顶层（非函数内）中的常量、类型、变量、非方法函数的标识符作用域是包块 package block
3. 一个导入的包的包名的标识符的作用域是导入这个包的那个文件块
4. 定义了方法接收器 receiver、函数参数或返回值的标识符的作用域是函数体
5. 函数内部的常量、变量和类型的标识符的作用域是从声明处开始到最内层的包含块的结尾处     

## Expressions 表达式

一个表达式通过对操作数应用操作符（运算符）和函数来得出一个计算值。     

### Operands 操作数

一个操作数可能是一个字面量，一个常量、变量或函数的标识符，或者是一个括号括起来的表达式。     

```go
Operand = Literal  | OperandName  | "(" Expression ")"
Literal = BasicLit | CompositeLit  | FunctionLit
BasicLit = int_lit | float_lit | imaginarg_lit | rune_lit | string_lit (布尔呢？？？)
OperandName = identifier | QualifiedIdent
```      

Qualified Identifiers 是指访问导入包的标识符。     

#### Composite literals 组合字面量

```
CompositeLit = LiteralType LiteralValue   // 话说正常情况下中间没空格吧
LiteralType = StructType  | ArrayType  | "["..."]" ElementType |  SliceType  | MapType  |  TypeName
LiteralValue = "{" [ ElementList [ ","] ] "}"
```     

### Operators

运算符将操作数组合到表达式中。     

```
二元运算符 = "||"  |   "&&"   | 关系运算符  | 加法运算符  | 乘法运算符
关系运算符 = "=" | "!="  |  "<"  | "<="  |  ">"  |  ">="
加法运算符 = "+" | "-"  | "|" |  "^"
乘法运算符 = "*"  | "/"  |  "%"  |  "<<"  |  ">>"   |  "&"  | "&^"

一元运算符 = "+"  |   "-"   |  "!"  |  "^"  |  "*"   |  "&"  | "<-"
```     

除比较运算符（关系运算符）外，其他的二元运算符都要求两边类型是相同的（相同的定义在上面
提到过），除非操作数涉及到移位或者是无类型的常量。话说这里 || 和 && 也不要求操作数类型一致吧。     


### Arithmetic operators

算术运算符可以对数值型使用，并产生一个和第一个操作数类型一致的值。+, -, *, / 对整数，
浮点，复数都可以使用，+ 还可对字符串使用，位逻辑运算符和移位运算符只能对整数使用。     

### Comparison operators

比较运算符会比较两个操作数并产生一个无类型的布尔值。     

```
==   !=   <  <=  >  >=
```     

`==` 和 `!=` 是对 _可比较_ 的操作数可以使用，而 `< <= > >=` 是针对 _可排序_ 的操作数
使用。这些术语和比较的结果定义如下：    

+ 布尔值可比较
+ 整型可比较，可排序
+ 浮点型可比较，可排序
+ 复数可比较
+ 字符串可比较，可排序，按照字节进行
+ 指针可比较，两个指针只有在指向同一变量或都是 nil 时相同
+ channel 可比较，两个 channel 只有在用相同的 make 调用创建或者都是 nil 时相同
+ 接口可比较，如果接口的动态类型和动态值都相等，或者两者都是 nil，就是相等的
+ 非接口类型 `X` 的值 `x` 和接口类型 `T` 值 `t` 可比较，只有当 `X` 是可比较的，并且 `X` 实现了接口 `T`。如果 `t` 的动态类型为 `X`，动态值为 `x` 则两者就想等
+ 结构体可比较，如果它们所有的字段都可比较
+ 数组元素类型可比较的情况下，数组就可比较       

slice, map 和 函数皆不可比较，不过它们可以和 nil 比较。     

### Logical operators

逻辑运算符对布尔值使用。     

```
&&   ||   !
```     

### Address operators

假设 `x` 的类型为 `T`, `&x` 会生成一个类型为 `*T` 的指针。操作数必须是 _可寻址的_。
这意味着，其可以是一个变量，一个指针的解引用操作，或者是切片的索引操作；或者是一个
可寻址的结构体操作数的字段选择符，或者是一个可寻址的数组的索引操作。唯一例外的是，`x`
可能是一个组合字面量。      




